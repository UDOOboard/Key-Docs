{"pages":[{"title":"UDOO Key Docs","text":"","tags":"","url":"index.html"},{"title":"Introduction","text":"UDOO KEY The UDOO KEY is a fully programmable board combining Raspberry Pi RP2040 microcontroller and ESP32-WROVER-E module from Espressif, coming together into a single, powerful solution of just 130 x 40 x 10.9 mm. UDOO KEY allows you to either use these two MCUs independently or to combine them, exploiting their unique features to realize infinite new applications. The Pico-compatible part of the UDOO KEY is built upon an RP2040 microcontroller by Raspberry Pi Foundation, dual Arm Cortex-M0+, with a QSPI 8MB Flash, a 133MHz clock and 264KB of on-chip SRAM. It is especially suitable for machine learning, motor control, and audio applications. The fully programmable ESP32 module, on the other hand, is an ESP32-WROVER-E based on a dual-core Xtensa 32-bit LX6, with a 16MB flash memory and an 8MB PSRAM. The ESP32 on board is also a Wi-Fi, Bluetooth and Bluetooth Low Energy module, thus providing the UDOO KEY with full wireless connectivity. The two microcontrollers can communicate via serial port or SWD interface. Both can be programmed using different environments, such as TinyML, TensorFlow Lite, MicroPython, C\/C++, Arduino IDE, and many more, giving you plenty of options to streamline your AI application. The UDOO KEY is also designed to natively support Clea, the AI platform by SECO Mind for deploying AI models and applications over a fleet of IoT devices through over-the-air updates. Download the User Manual to have a more complete explanation of the UDOO KEY hardware and features. Visit the Get Started - ESP32 and IDF, Get Started - ESP32 and Arduino Get Started - RP2040 and MicroPython and Get Started - RP2040 and Arduino sections to learn how to start using your UDOO KEY. Lineup The UDOO KEY retail line up consists of two models, which are mainly distinguished by the availability of on-board sensors: UDOO KEY Basic UDOO KEY Pro Check the Board Versions section to see the differences between the two. Moreover, by looking at the following video, you can have a brief overview of the UDOO board and its components. Technical specifications Power supply: 5V DC Dimensions: 130 x 40 x 10.9 mm Sensors: On-chip temperature sensor 6-axis IMU motion sensor (only on UDOO KEY Pro) Omnidirectional Digital Microphone (only on UDOO KEY Pro) Microcontrollers ESP32 RP2040 Memory size 8 MB SPI Pseudo static RAM 264 KB SPI Pseudo static RAM Flash size 16 MB internal SPI flash 64 M-bit external QSPI flash Connectivity Wi-Fi 802.11 b\/g\/n (802.11n up to 150 Mbps), Bluetooth v4.2 BR\/EDR and BLE specification - Peripherals UEXT connector (I2C, SPI, UART) 26 multifunction GPIO pins Community Official web site: www.udoo.org Official forum: www.udoo.org\/forum Forums The official UDOO forums can be found at www.udoo.org\/forum The forum search facility has been tweaked to allow more general searching. Please do a search before making a post as the issue may already have been raised and answered. IRC channel There is an (unofficial) UDOO discussion channel on IRC. Using the IRC client of your choice, use server information: irc.freenode.net. Room name is #udoo. Social networks Facebook page Telegram group YouTube Twitter Instagram","tags":"","url":"Introduction\/Introduction.html"},{"title":"Overview","text":"Hardware reference Overview In the above image is represented the name of on-board components used in following sections and in the schematic file. Following the role of each component. Name Description CN1 USB type-C connector P1, P2 RP2040 external connectors P3 UEXT connector to ESP32 P4 I\u00b2C select jumper P5 External SWD connector to RP2040 JP1 USB select jumper JP2 Boot mode selector ESP32 SW1, SW2, SW3 Switch buttons D12, D17, D18 LEDs Block diagram","tags":"","url":"Hardware_References\/Overview.html"},{"title":"Full specs","text":"Full Specifications Below the full technical specifications ESP32 RP2040 Memory 8 MB PSRAM 264 KB PSRAM Flash storage 16 MB internal SPI flash 64M-bit external QSPI flash Connectivity Wi-Fi 802.11 b\/g\/n (802.11n up to 150 Mbps), Bluetooth v4.2 BR\/EDR and BLE specification - RF power WiFi: 20 dBm, BT:13.7 dBM - Modulation type GFSK, OFDM - Frequency bands 2400 \u00f7 2483.5 MHz - Bandwidth BT \/ BLE: 1 MHz (79 channels) \/ 2 MHz (40 channels) - Peripherals UART, I\u00b2C, SPI on UEXT connector, blue and yellow LEDS, SWD lines to RP2040 UART, SPI, I\u00b2C on P1 and P2 , green LED Sensors SPK0838HT4H-1 Microphone, shared MPU-6500 IMU Shared MPU-6500 IMU Operating temperature: 0\u00b0C \u00f7 +60\u00b0C Power supply: +5VDC Dimensions: 130 x 40 x 10.9 mm Resources In addition to this guide, several ones are available online: for a full explanation of the UDOO KEY hardware download the UDOO KEY User Manual see the Get Started - ESP32 and IDF, Get Started - ESP32 and Arduino, Get Started - RP2040 and MicroPython and Get Started - RP2040 and Arduino sections for all the useful information for a quick installation here you can find the schematics file for the UDOO KEY official ESP32 development framework Raspberry PI PICO datasheet Raspberry PI PICO C\/C++ SDK MicroPython download page for RP2040 Board versions The UDOO KEY is available in two versions: UDOO KEY Basic and UDOO KEY Pro. The UDOO KEY Basic mounts no sensors, it is therefore perfect for those who want full control of their project, as it allows expansion with modules of developer\u2019s choice. The UDOO KEY Pro mounts two powerful sensors: a 6-axis IMU and a digital microphone. The 6-axis IMU motion sensor, an MPU-6500, combines an accelerometer and a gyroscope in a single module to streamline a wide array of projects, from robotics and RC cars up to smart bikes and automation. It is connected to the ESP32 via I2C bus. You can decide whether to access the I2C bus via ESP32 or RP2040 through the jumper switch. The omnidirectional digital microphone, a SPK0838HT4H, is designed for AI-powered sound &amp; voice recognition as well as audio control. It is connected to the ESP32 via I2S bus. The following table and picture summarize the differences between the UDOO KEY Basic and the UDOO KEY Pro. UDOO KEY Basic UDOO KEY Pro Sensors on chip temperature sensor (RP2040) on chip temperature sensor (RP2040) 6-axis IMU motion sensors omnidirectional digital microphone Notice that, only for kickstarters, the IMU sensor has been changed and is currently installed the model MPU-6500, a 6-axis motion tracking sensor. Board headers The UDOO KEY features four useful pinout header. The pin header connector P3 on the top of the board is compliant with the UEXT specification and is accessible from the ESP32. It exposes the I2C, UART, and SPI interfaces. The two headers on the bottom of the board, P1 and P2, are 100% compatible with Raspberry Pi Pico, both hardware and software-wise \u2013 except for two GPIO pins used for UART mapping, namely GP0 and GP1, to ensure the communication between the ESP32 and the RP2040. This means that each and any expansion hardware as well as software built for Raspberry Pi Pico will work out of the box on the UDOO KEY. Finally, on P5 header are connected SWD lines (SWDCLK, GND and SWDIO) to easly program the RP2040, as for the Raspberry Pi Pico. Power source The UDOO KEY can be powered by an external power supply of +5V DC (max 2.5A) via USB Type-C connector (C1). The board is also provided with a 2.5A 32V DC fuse to protect itself from overcurrent injection. The USB Type-C connector powers up both the ESP32-WROVER-E module and the RP2040, and all peripherals connected on. The UDOO KEY can go into deep sleep, reducing the power consumption to a minimum. In this state it only awakes if triggered by a specific event, thus extending battery life up to several years.","tags":"","url":"Hardware_References\/Full_specs.html"},{"title":"ESP32","text":"The UDOO KEY is powered by Espressif ESP32-WROVER-E MCU module, a powerful and versatile platform for Edge AI applications, ranging from low-power sensor networks to the most demanding tasks, such as voice encoding, music streaming and MP3 decoding. This module is provided with a PCB antenna. This fully programmable microcontroller is based on a dual-core Xtensa 32-bit LX6, with a 16 MB internal SPI flash memory, an additional 8 MB SPI Pseudo Static RAM (PSRAM), Wi-Fi and Bluetooth. The core of the module is the ESP32-D0WD-V3 chip, which is designed to be scalable and adaptive. It features two CPU cores that can be individually controlled, and the CPU clock frequency is adjustable from 80 MHz to 240 MHz. The chip is also provided with a low-power co-processor that can be used instead of the CPU to save power while performing tasks that do not require much computing power, such as perihperals monitoring. Thanks to the ESP32 on board, you get full Wi-Fi 802.11b\/g\/n connectivity, Bluetooth and BLE v4.2. This ensures the UDOO KEY extreme versatility: the Wi-Fi allows to set up direct connection to the internet through a Wi-Fi router, while using the Bluetooth users can connect to their phones or broadcast low energy beacons for its detection. Note that the ESP32 on board is not just a Wi-Fi, BT &amp; BLE module. It gives you full access to the firmware of ESP32 and you can program it as you please. The sleep current of the ESP32 chip is less than 5 \u00b5A, making it suitable for battery powered and wearable electronics applications. The module supports a data rate of up to 150 Mbps, 802.11b at 13.5dBm, and 802.11g\/n at 18.5 dBm of output power to the antenna to ensure the widest physical range. The module thus offers industry-leading specifications and the best performance for electronic integration, range, power consumption, and connectivity. Secure (encrypted) over the air (OTA) upgrade is also supported, so that users can upgrade their products even after their release, at minimum cost and effort. For further information on Espressif ESP32, please refer to the dedicated page on espressif.com. In order to be able to interface the ESP32 with external integrated circuits, the target MCU is equipped with an UEXT connector following the pin map as reported in the table below. Pin number Schematic pin name ESP GPIO Description 1 3V3 - 3.3V output, 150mA max 2 GND - Power ground 3 EXT_UART2_TX GPIO13 UART transmission line 4 EXT_UART2_RX GPIO26 UART reception line 5 ESP32_SCL GPIO21 I\u00b2C clock line 6 ESP32_SDA GPIO18 I\u00b2C data line 7 SPI_MISO GPIO35 SPI Microcontroller in \/ Sensor out 8 SPI_MOSI GPIO12 SPI Microcontroller out \/ Sensor in 9 SPI_SCK GPIO14 SPI clock 10 SPI_CS GPIO15 SPI chip select","tags":"","url":"Hardware_References\/ESP32.html"},{"title":"RP2040","text":"The Pico-compatible part of the UDOO KEY is built upon a Raspberry Pi RP2040 microcontroller, dual Arm Cortex-M0+, with a QSPI 8MB Flash, a 133MHz clock and 264KB of on-chip SRAM. The RP2040 microcontroller is a chip from Raspberry Pi Foundation that integrates two Arm Cortex-M0+ CPUs that can be run up to 133MHz, featuring 264kB of on-chip SRAM and up to 16MB of off-chip Flash memory. This microcontroller can be used for machine learning, motor control, audio and so on. The UDOO KEY is 100% compatible with Raspberry Pi Pico both hardware and software-wise. This means that each and any expansion hardware as well as each and any software built for Raspberry Pi Pico will work out of the box on UDOO KEY. For further information on RP2040, please refer to the dedicated page on raspberrypi.com. P1 and P2 connectors of the Pico part can be used to connect external peripherals to the RP2040. Two 20-pin headers or castellated holes must be soldered on P1 and P2 in a proper manner to use them . The following tables summarize the possibilities offered by P1 and P2 connectors. P1 Pin number Schematic pin name SPI UART interface I\u00b2C PWM SIO\/PIO 1 N.C. - - - - - 2 N.C. - - - - - 3 GND - - - - - 4 RPI_SDA SPI0_SCK UART0_CTS I2C1_SDA PWM1_A SIO\/PIO0\/PIO1 5 RPI_SCL SPI0_TX UART0_RTS I2C1_SCL PWM1_B SIO\/PIO0\/PIO1 6 GP4 SPI0_RX UART1_TX I2C0_SDA PWM2_A SIO\/PIO0\/PIO1 7 GP5 SPI0_CSn UART1_RX I2C0_SCL PWM2_B SIO\/PIO0\/PIO1 8 GND - - - - - 9 GP6 SPI0_SCK UART1_CTS I2C1_SDA PWM3_A SIO\/PIO0\/PIO1 10 GP7 SPI0_TX UART1_RTS I2C1_SCL PWM3_B SIO\/PIO0\/PIO1 11 GP8 SPI1_RX UART1_TX I2C0_SDA PWM4_A SIO\/PIO0\/PIO1 12 GP9 SPI1_CSn UART1_RX I2C0_SCL PWM4_B SIO\/PIO0\/PIO1 13 GND - - - - - 14 GP10 SPI1_SCK UART1_CTS I2C1_SDA PWM5_A SIO\/PIO0\/PIO1 15 GP11 SPI1_TX UART1_RTS I2C1_SCL PWM5_B SIO\/PIO0\/PIO1 16 GP12 SPI1_RX UART0_TX I2C0_SDA PWM6_A SIO\/PIO0\/PIO1 17 GP13 SPI1_CSn UART0_RX I2C0_SCL PWM6_B SIO\/PIO0\/PIO1 18 GND - - - - - 19 GP14 SPI1_SCK UART0_CTS I2C1_SDA PWM7_A SIO\/PIO0\/PIO1 20 GP15 SPI1_TX UART0_RTS I2C1_SCL PWM7_B SIO\/PIO0\/PIO1 Pin number 1 and 2 are not connected since are used for MCUs communication. P2 Pin number Schematic pin name SPI UART interface I\u00b2C PWM SIO\/PIO 1 GP16 SPI0_RX UART0_TX I2C0_SDA PWM0_A SIO\/PIO0\/PIO1 2 GP17 SPI0_CSn UART0_RX I2C0_SCL PWM0_B SIO\/PIO0\/PIO1 3 GND - - - - - 4 GP18 SPI0_SCK UART0_CTS I2C1_SDA PWM1_A SIO\/PIO0\/PIO1 5 GP19 SPI0_TX UART0_RTS I2C1_SCL PWM1_B SIO\/PIO0\/PIO1 6 GP20 SPI0_RX UART1_TX I2C0_SDA PWM2_A SIO\/PIO0\/PIO1 7 GP21 SPI0_CSn UART1_RX I2C0_SCL PWM2_B SIO\/PIO0\/PIO1 8 GND - - - - - 9 GP22 SPI0_SCK UART1_CTS I2C1_SDA PWM3_A SIO\/PIO0\/PIO1 10 RPI_RESET - - - - - 11 GP26 SPI1_SCK UART1_CTS I2C1_SDA PWM5_A SIO\/PIO0\/PIO1 12 GP27 SPI1_TX UART1_RTS I2C1_SCL PWM5_B SIO\/PIO0\/PIO1 13 GND - - - - - 14 GP28 SPI1_RX UART0_TX I2C0_SDA PWM6_A SIO\/PIO0\/PIO1 15 ADC_VREF - - - - - 16 3V3 - - - - - 17 N.C. - - - - - 18 GND - - - - - 19 VSYS - - - - - 20 VBUS - - - - - Pin number: 10 is reserved for RP2040 reset by ESP32 16 provide 3.3V DC (315mA) in output 17 is not connected 19 provide 5V DC (500mA) filtered from USB Type-C connector (CN1) 20 provide 5V DC (500mA) raw from USB Type-C connector (CN1) P5 The Serial Wire Debug interface is available on the 1x3 poles connector P5. This header allows you to program and debug the RP2040 microcontroller externally. The following table shows the pin configuration. Pin number Function 1 SWCLK 2 GND 3 SWDIO","tags":"","url":"Hardware_References\/RP2040.html"},{"title":"MCUs connections","text":"To let you to create projects that leverage the power of both microcontrollers, they are connected through a serial connection. Such connection uses GPIO0 (TX) and GPIO1 (RX) on RP2040 and, on ESP32, IO19 (TX) and IO22 (RX). On schematic file those connections are labeled with RPI_UART_TX and RPI_UART_RX. Keep in mind that RP GPIO0 is connected to ESP IO22 and, vice versa, GPIO1 is connected with IO19. Thanks to this connection you can exchange between the MCUs whichever stream of bytes. There are cases in which the RP2040 must be restarted remotely: you can perform this operation from the ESP32. The pin number 10 on P2 header (RPI_RESET) is connected to ESP pin IO23. By setting its output level LOW the RP2040 execution is disabled, while, setting output level HIGH, the RP2040 execution is restored. So, to reset the Raspberry microcontroller from ESP, let's set the output level LOW and then move to HIGH. Moreover, to enable RP2040 OTA programming, its SWD lines are connected to ESP pins as shown in the following table. ESP GPIO NUM RP SWD interface IO2 SWDIO IO4 SWCLK Since the RP2040 can be programmed also through on-board SWD header P5, the user must ensure that, while he want to use such interface, the GPIO IO5 level is set to HIGH. To use external headers, such GPIO must be set to LOW level. Keep in mind that the IMU sensor is connected to both microcontrollers and, to select which of them can interact with it, a jumper must be inserted as explained in the following table. As explained in the schematic file, pin number 1 is the closest to the RP2040 and pin number 3 is the closest to the ESP32. Jumper position IMU Sensor connected to Not placed ESP32 (Default) Pin 1-2 RP2040 Pin 2-3 ESP32","tags":"","url":"Hardware_References\/MCUs_connections.html"},{"title":"Get started with ESP32 and IDF","text":"This is the new version of the ESP-IDF getting started guide, using a newer version and with corrected typos. If you want to check the older version, go to this page. After speaking a long about technical specifications and boards components, let's start doing things in order to load firmware in flash memory of microcontrollers! Now we will install all dependencies and frameworks, in Linux-based and Windows OSs, for ESP32 microcontroller and start programming it. The framework we chose is the official one, the ESP-IDF, but several other frameworks can be used to programming the ESP32. Among the others the most used are MicroPython and Arduino. Choose the one you prefer! Linux Here you can find the official documentation that explains with many more details the installation. For a quick guide read below! In addition to following packages, a text editor is required: you can use VS Code or emacs or whatever you want! Open a terminal and type the following commands: # Install the essential dependencies sudo apt install cmake wget git python3 python3-pip virtualenv # Create the workspace folder (if it doesn't exist yet), clone the repository of ESP-IDF version 5.0.4 and install it mkdir ~\/ws\/esp cd ~\/ws\/esp git clone --recursive https:\/\/github.com\/espressif\/esp-idf.git -b v5.0.4 cd esp-idf bash install.sh esp32 # Before programming the ESP32, a set of environment variables need to be defined in the shell environment # Let's create an alias to easily load them and invoke it for each terminal you need cd ~ echo &quot;alias get_idf='. $HOME\/ws\/esp\/esp-idf\/export.sh'&quot; &gt;&gt; ~\/.bash_aliases source $HOME\/.bash_aliases get_idf # The environment is correctly loaded! It's the moment to create and load on your board the first program that makes the two on-board LEDs blink! Open a terminal and type: # First of all load the needed variables by calling the alias get_idf cd ~\/ws\/esp # Create the project idf.py create-project blinker cd blinker\/main Open the blinker.c file inside current folder and copy the content below inside it. It is the entry-point of your firmware and contains the instruction to perform the actions we want. #include &lt;stdio.h&gt; #include &lt;driver\/gpio.h&gt; #include &lt;freertos\/FreeRTOS.h&gt; #include &lt;freertos\/task.h&gt; #define B_LED_PIN GPIO_NUM_32 #define Y_LED_PIN GPIO_NUM_33 void led_blinker_task (void) { esp_rom_gpio_pad_select_gpio(B_LED_PIN); gpio_set_direction (B_LED_PIN, GPIO_MODE_OUTPUT); esp_rom_gpio_pad_select_gpio(Y_LED_PIN); gpio_set_direction (Y_LED_PIN, GPIO_MODE_OUTPUT); while (1) { gpio_set_level(Y_LED_PIN, 0); gpio_set_level(B_LED_PIN, 0); gpio_set_level(B_LED_PIN, 1); vTaskDelay(pdMS_TO_TICKS(128)); gpio_set_level(B_LED_PIN, 0); vTaskDelay(pdMS_TO_TICKS(128)); gpio_set_level(B_LED_PIN, 1); vTaskDelay(pdMS_TO_TICKS(128)); gpio_set_level(B_LED_PIN, 0); gpio_set_level(Y_LED_PIN, 1); vTaskDelay(pdMS_TO_TICKS(2000)); } } void app_main(void) { xTaskCreate (&amp;led_blinker_task, &quot;led_blinker_task&quot;, 1024, NULL, 2, NULL); } Now that everything is ready, you can build and flash the program. As explained in the video at the beginning of this page, you must leave the jumper JP1 opened to drive the serial communication to ESP microcontroller and then you can connect your board to PC. After the connection, a serial port appears on your file system. Its path can be \/dev\/ttyUSB0 or \/dev\/ttyUSB1 or \/dev\/ttyUSB2 and so on, depending if you already have connected serial devices. In the following commands, the port path is referred with &lt;PORT&gt; string. Finally you have to put the target MCU in flash mode, so close the jumper JP2 and push the button SW3 to reset it. The microcontroller can be programmed! To do that, in a terminal with environment variales already loaded, type the following commands: cd ~\/ws\/esp\/blinker idf.py -p &lt;PORT&gt; build flash monitor The above command will build the entire project (build command), will load the firmware into the ESP flash memory (flash command) and will monitor the output produced by the microcontroller and sent via the serial connection (monitor command). Keep in mind that you can also invoke build, flash, and monitor commands separately. Type the command idf.py help to get the full list of available commands. At this point the board need to be resetted to execute the just flashed firmware. Let's open the jumper JP2 and push the reset button SW3 to see LEDs in action! Windows For Windows OS installation, Espressif provides an installer which automatically performs everything. Firstly download the installer here and launch it. After the installation, you can open a ESP-IDF prompt by searching for ESP-IDF 5.0.4 CMD entry in the Start menu. Once launched, a new prompt is executed with the environment already loaded. If everything has been installed fine, you can create a project. To do that copy the code and flash the ESP32 in the same way explained for the Linux OS using an ESP-IDF command prompt. To obtain more information about the Windows OS, here you can find the official documentation.","tags":"","url":"Get_Started\/Get_started_with_ESP32_and_IDF.html"},{"title":"Get started with ESP32 - deprecated","text":"This page has been deprecated! Go to this page to read the guide with ESP-IDF version 5.0.4 and corrected typos. After speaking a long about technical specifications and boards components, let's start doing things in order to load firmware in flash memory of microcontrollers! Now we will install all dependencies and frameworks, in Linux-based and Windows OSs, for ESP32 microcontroller and start programming it. The framework we chose is the official one, the ESP-IDF, but several other frameworks can be used to programming the ESP32. Among the others the most used are MicroPython and Arduino. Choose the one you prefer! Linux Here you can find the official documentation that explains with many more details the installation. For a quick guide read below! Additionally you can watch in the video below the full installation procedure explained and executed on a PC. In addition to following packages, a text editor is required: you can use VS Code or emacs or whatever you want! Open a terminal and type the following commands: # Install the essential dependencies sudo apt install cmake wget git python3 python3-pip virtualenv # Create the workspace folder (if it doesn't exist yet), clone the repository of ESP-IDF version 4.4.1 and install it mkdir ~\/ws\/esp cd ~\/ws\/esp git clone --recursive https:\/\/github.com\/espressif\/esp-idf.git -b 4.4.1 cd esp-idf bash install.sh esp32 # Before programming the ESP32, a set of environment variables need to be defined in the shell environment # Let's create an alias to easily load them and invoke it for each terminal you need cd ~ echo &quot;alias get_idf='. $HOME\/ws\/esp\/esp-idf\/export.sh'&quot; &gt;&gt; ~\/.bash_aliases source $HOME\/.bash_aliases get_idf # The environment is correctly loaded! It's the moment to create and load on your board the first program that makes the two on-board LEDs blink! Open a terminal and type: # First of all load the needed variables by calling the alias get_idf cd ~\/ws\/esp # Create the project idf.py create-project blinker cd blinker\/main Open the blinker.c file inside current folder and copy the content below inside it. It is the entry-point of your firmware and contains the instruction to perform the actions we want. #include &lt;stdio.h&gt; #include &lt;driver\/gpio.h&gt; #include &lt;freertos\/FreeRTOS.h&gt; #include &lt;freertos\/task.h&gt; #define B_LED_PIN GPIO_NUM_32 #define Y_LED_PIN GPIO_NUM_33 void led_blinker_task () { gpio_pad_select_gpio(B_LED_PIN); gpio_set_direction (B_LED_PIN, GPIO_MODE_OUTPUT); gpio_pad_select_gpio(Y_LED_PIN); gpio_set_direction (Y_LED_PIN, GPIO_MODE_OUTPUT); while (1) { gpio_set_level(Y_LED_PIN, 0); gpio_set_level(B_LED_PIN, 0); gpio_set_level(B_LED_PIN, 1); vTaskDelay(pdMS_TO_TICKS(128)); gpio_set_level(B_LED_PIN, 0); vTaskDelay(pdMS_TO_TICKS(128)); gpio_set_level(B_LED_PIN, 1); vTaskDelay(pdMS_TO_TICKS(128)); gpio_set_level(B_LED_PIN, 0); gpio_set_level(Y_LED_PIN, 1); vTaskDelay(pdMS_TO_TICKS(2000)); } } void app_main(void) { xTaskCreate (&amp;led_blinker_task, &quot;led_blinker_task&quot;, 1024, NULL, 2, NULL); } Now that everything is ready, you can build and flash the program. As explained in the video at the beginning of this page, you must leave the jumper JP1 opened to drive the serial communication to ESP microcontroller and then you can connect your board to PC. After the connection, a serial port appears on your file system. Its path can be \/dev\/ttyUSB0 or \/dev\/ttyUSB1 or \/dev\/ttyUSB2 and so on, depending if you already have connected serial devices. In the following commands, the port path is referred with &lt;PORT&gt; string. Finally you have to put the target MCU in flash mode, so close the jumper JP2 and push the button SW3 to reset it. The microcontroller can be programmed! To do that, in a terminal with environment variales already loaded, type the following commands: cd ~\/ws\/esp\/blinker idf.py -p &lt;PORT&gt; build flash monitor The above command will build the entire project (build command), will load the firmware into the ESP flash memory (flash command) and will monitor the output produced by the microcontroller and sent via the serial connection (monitor command). Keep in mind that you can also invoke build, flash, and monitor commands separately. Type the command idf.py help to get the full list of available commands. At this point the board need to be resetted to execute the just flashed firmware. Let's open the jumper JP2 and push the reset button SW3 to see LEDs in action! Windows For Windows OS installation, Espressif provides an installer which automatically performs everything. Firstly download the installer here and launch it. After the installation, you can open a ESP-IDF prompt by searching for ESP-IDF 4.4 CMD entry in the Start menu. Once launched, a new prompt is executed with the environment already loaded. If everything has been installed fine, you can create a project. To do that copy the code and flash the ESP32 in the same way explained for the Linux OS using an ESP-IDF command prompt. To obtain more information about the Windows OS, here you can find the official documentation.","tags":"","url":"Get_Started\/Get_started_with_ESP32_deprecated.html"},{"title":"Get started with ESP32 and Arduino","text":"In this guide you will learn how to play with the Arduino framework and the ESP32 microcontroller of your new UDOO KEY board. It is quite easy since it works like any other ESP32 based board. First of all, let's download and install the Arduino IDE following the official documentation. Now you have to properly setup the IDE in order to use it with the board. Leave the jumper labeled with Serial Sel open, to drive the USB communication to the ESP32 and connect the board to your PC using a USB cable. The connected device will be discovered by your PC as COM8 port in Windows OS or as \/dev\/ttyUSB0 device in Linux based OSs. Check the correct port or device before continuing. Once the port has been found, open the IDE and follow the instructions below to add the ESP32 support to the board manager. Open Preferences window by selecting File and then Preferences.... On the Settings tab, insert the URL https:\/\/raw.githubusercontent.com\/espressif\/arduino-esp32\/gh-pages\/package_esp32_index.json in Additional boards manager URLs field and then click on the OK button. Install the ESP32 board support from the Boards Manager by selecting Tools, Board and Boards Manager.... Search the esp32 text and, among the filtered results, select esp32 by Espressif Systems and click the INSTALL button. When the installation has finished, select the correct connected board and its port, depending on the OS. On Windows it will be something like COM8 (use the Device Manager to find the correct one) and on Linux based OSs you will have a device file like \/dev\/ttyUSB0. Now choose the example you want to load on the microcontroller clicking on File, Examples and then on the project. In this guide we will flash the Blink sketch from the 01.Basics sub-menu. In order to blink alternatively the two on-board LEDs connected to the ESP microcontroller, some changes have to be applied on the original source code. The final code is: #define BLUE_LED_PIN 32 #define YELLOW_LED_PIN 33 \/\/ the setup function runs once when you press reset or power the board void setup() { \/\/ initialize digital pins as output. pinMode(BLUE_LED_PIN, OUTPUT); pinMode(YELLOW_LED_PIN, OUTPUT); } \/\/ the loop function runs over and over again forever void loop() { digitalWrite(BLUE_LED_PIN, HIGH); \/\/ turn the blue LED on (HIGH is the voltage level) digitalWrite(YELLOW_LED_PIN, LOW); \/\/ turn the yellow LED off by shifting the voltage LOW delay(1000); \/\/ wait for a second digitalWrite(YELLOW_LED_PIN, HIGH); \/\/ turn the yellow LED on (HIGH is the voltage level) digitalWrite(BLUE_LED_PIN, LOW); \/\/ turn the blue LED off by shifting the voltage LOW delay(1000); \/\/ wait for a second } Differently from the RP2040 microcontroller, you must put the ESP32 in flash mode by closing the jumper JP2 and pressing reset button before upload the firmware. After that, you can upload the sketch to the microcontroller by clicking the &quot;Upload&quot; button. Once the upload has finished, you must manually reset the MCU to see the LEDs blinking.","tags":"","url":"Get_Started\/Get_started_with_ESP32_and_Arduino.html"},{"title":"Get started with RP2040 and MicroPython","text":"We will install all the dependencies, in both Linux-based and Windows OSs, to play with the MicroPython framework. We have chosen this development environment because it's easy to learn and has a great support from the community. As for the other on-board microcontroller, there exist several frameworks that support the RP2040. To write firmwares for the RP2040, you can use the official C\/C++ SDK, the Rust crate for the Pico board or the Arduino SDK. Choose the one you feel more comfortable with. We have recorded a video in which all steps described below are directly executed on a PC. Here a distinction between the Linux-based and Windows OSs is not needed, since MicroPython is host platform agnostic. First of all you need to install python3 and python3-pip, but they are already installed by following the guide for ESP32 and IDF part. You also need to install the rshell python package. It s needed to upload the python code and interact with the MicroPython interpreter running on the MCU. In a command line, type: python3 -m pip install rshell Now upload the MicroPython firmware into RP flash. Firstly, download its latest release from this page. Then put the microcontroller in flash mode: close the jumper JP1 to allow the computer to interact with RP and connect the board to your PC using an USB Type-C cable. Keep pressed the button SW2 labeled as BOOTSEL and push the reset button SW1. After these operations, the board is detected as a removable device by your computer. Simply copy the just downloaded .uf2 file and paste it into the removable drive. In this way you can program the Raspberry MCU! Once the MicroPython framework has been loaded, create a file called main.py and copy the following code on it. It will make the LED attached on pin 25 blink each 750 milliseconds! from machine import Pin import time LED_PIN=25 led = Pin(LED_PIN, Pin.OUT) while True : led.toggle () time.sleep (.750) To load the script on your board, move to the folder containing the main.py file using a command line (let's call it rp placed in ws folder), and type the following commands: cd ws\/rp # Invoke the rshell program rshell # It will automatically find the board, if correctly plugged # Now you can copy the main.py source file by copying it into \/pyboard folder which represent the connected board cp main.py \/pyboard\/main.py To apply changes, close the rshell program and reset the board with on-board button SW1. At this moment the LED will start blinking! To implement complex project using MicroPython you can find its official documentation here and the documentation for RP2040 specific functionalities here. Enjoy with your UDOO KEY!","tags":"","url":"Get_Started\/Get_started_with_RP2040_and_MicroPython.html"},{"title":"Get started with RP2040 and Arduino","text":"In this guide you will learn how to play with the Arduino framework and the RP2040 microcontroller of your new UDOO KEY board. It is quite easy since it works like any other Raspberry Pi PICO board. First of all, let's download and install the Arduino IDE following the official documentation. Now you have to properly setup the IDE in order to use the board. Close the jumper labeled with Serial Sel to drive the USB communication to the RP2040 and connect the board to your PC using a USB cable. The connected device will be discovered by your PC as COM6 port in Windows OS or as \/dev\/ttyACM0 device in Linux based OSs. Check the correct port or device before continuing. Once the port has been found, open the IDE and follow the instructions below to add the Raspberry Pi Pico to the board manager. Open Preferences window by selecting File and then Preferences.... On the Settings tab, insert the URL https:\/\/github.com\/earlephilhower\/arduino-pico\/releases\/download\/global\/package_rp2040_index.json in Additional boards manager URLs field and then click on the OK button. Install the RP2040 board support from the Boards Manager by selecting Tools, Board and Boards Manager.... Search the pico text and, among the filtered results, select Raspberry Pi Pico\/RP2040 and click the INSTALL button. When the installation has finished, select the correct connected board and its port, depending on the OS. On Windows it will be something like COM6 (use the Device Manager to find the correct one) and on Linux based OSs you will have a device file like \/dev\/ttyACM0. Now choose the example you want to load on the microcontroller clicking on File, Examples, rp2040 and then on the project. In this guide we will flash the Fade sketch. Finally you can upload the sketch to the microcontroller by clicking the &quot;Upload&quot; button. The IDE will put automatically the MCU in flash mode without the need of additional user operations. Once the upload has finished, the on-board led will start to fade as expected!","tags":"","url":"Get_Started\/Get_started_with_RP2040_and_Arduino.html"},{"title":"ESP accessories","text":"This chapter will come soon!","tags":"","url":"Compatible_Accessories\/ESP_accessories.html"},{"title":"RP accessories","text":"This chapter will come soon!","tags":"","url":"Compatible_Accessories\/RP_accessories.html"},{"title":"Get started with MPU6500","text":"Get started with MPU6500 IC Those of you who purchased the UDOO KEY PRO will be eager to try the on-board sensors as soon as possible! In this guide we'll show you how to easily test the on-board accelerometer, MPU-6500, with the esp-idf v5.0.2 framework. Install it on your PC and let's start coding! MPU tester project The code we are going to show in this little guide has been pushed on this repository: those of you who want to quickly test and integrate the accelerometer driver on their project can clone, check and use it. Instead, if you want an explanation about the wrote code, simply continue reading below. Step-by-step guide First of all you have to install the esp-idf version 5.0.2 on your development PC: if you already haven't, install it following the instructions on the offical Espressif page. The developed project has been tested on Ubuntu 20.04 OS but, thanks to the esp-idf support, it can be compiled on each supported OS. To communicate with the accelerometer and get sensed values we need the driver https:\/\/github.com\/natanaeljr\/esp32-MPU-driver.git developed by natanalejr. The project above depends on a wrapper around the esp-idf libraries to communicate over the ESP32 I\u00b2C bus: https:\/\/github.com\/natanaeljr\/esp32-I2Cbus.git. Both of them will be added later as managed components using the IDF Component Manager tool. Project creation and setup In this first step we will create the project. Thanks to the esp-idf support it it a simple operation. You have to move to the workspace folder and type: idf.py create-project mpu6500-tester Then create the idf_component.yml file inside the main component folder and paste the following text: ## IDF Component Manager Manifest File dependencies: ## Required IDF version idf: version: &quot;&gt;=5.0.2&quot; accelerometer-driver implementation Firstly you have to create the new component by moving to the root project folder and creating the component acclerometer-driver typing: cd mpu6500-tester idf.py create-component accelerometer-driver -C components Since the esp32-MPU-driver and esp32-I2Cbus components are written in C++, you can include them in your C++ project or, if your project is composed by C sources, you need to create a wrapper around C++ classes in order to use them. Here we show the second option since the first one is a fairly simple operation and don't necessarily need a wrapper component. So let's create the MPU-driver-wrapper.cpp file in the same directory of accelerometer-driver.c file: it will contain a set of functions that can be used to invoke C++ methods. Then update the CMakeLists.txt file content to include the just created file in the compilation process. The new content can be as follow: idf_component_register( SRCS &quot;accelerometer-driver.c&quot; &quot;MPU-driver-wrapper.cpp&quot; INCLUDE_DIRS &quot;include&quot;) To add required dependencies to accelerometer-driver component, create the idf_component.yml file in the root directory of the target component and paste the following text: ## IDF Component Manager Manifest File dependencies: ## Required IDF version idf: version: &quot;&gt;=5.0.2&quot; MPU-driver: version: &quot;master&quot; git: https:\/\/github.com\/natanaeljr\/esp32-MPU-driver.git I2Cbus: version: &quot;master&quot; git: https:\/\/github.com\/natanaeljr\/esp32-I2Cbus.git Finally, to clone locally the dependencies, go to the root folder of project and type: idf.py reconfigure Now it's time to add the acclerometer-driver implementation! First of all, define the data structures and functions inside the accelerometer-driver.h file: you need a sensor descriptor structure, an initializer for the component and two functions to read the accelerometer and gyroscope data. Since you cannot refer to a C++ classes inside a C source file, the mpu6500_sensor_t contains a void * reference which will point to the actual driver class. The header file content can be as follow: #pragma once #include &lt;esp_err.h&gt; typedef struct { void *driver_object; } mpu6500_sensor_t; esp_err_t mpu6500_sensor_init(mpu6500_sensor_t **target_sensor); esp_err_t accelerometer_read(mpu6500_sensor_t *sensor, float *ax, float *ay, float *az); esp_err_t gyroscope_read(mpu6500_sensor_t *sensor, float *gx, float *gy, float *gz); The implementation of such functions, contained in accelerometer-driver.c file, can be: #include &lt;esp_err.h&gt; #include &lt;esp_log.h&gt; #include &lt;string.h&gt; #include &lt;accelerometer-driver.h&gt; const char *TAG = &quot;accelerometer-driver&quot;; extern void *mpu_get_new_driver_object(); extern esp_err_t mpu_accelerometer_read(void *, float *, float *, float *); extern esp_err_t mpu_gyroscope_read(void *, float *, float *, float *); esp_err_t mpu6500_sensor_init(mpu6500_sensor_t **target_sensor) { if (*target_sensor != NULL) { ESP_LOGE(TAG, &quot;Target sensor structure alreeady existing!&quot;); return ESP_ERR_INVALID_ARG; } *target_sensor = (mpu6500_sensor_t *) malloc(sizeof(mpu6500_sensor_t)); memset(*target_sensor, '\\0', sizeof(mpu6500_sensor_t)); (*target_sensor)-&gt;driver_object = mpu_get_new_driver_object(); return ESP_OK; } esp_err_t accelerometer_read(mpu6500_sensor_t *sensor, float *ax, float *ay, float *az) { return mpu_accelerometer_read(sensor-&gt;driver_object, ax, ay, az); } esp_err_t gyroscope_read(mpu6500_sensor_t *sensor, float *gx, float *gy, float *gz) { return mpu_gyroscope_read(sensor-&gt;driver_object, gx, gy, gz); } Such functions simply calls extern functions, that will be defined and implemented in MPU-driver-wrapper.cpp file, which contain the relevant business logic. So the content of such file can be: #include &lt;esp_log.h&gt; #include &lt;esp_err.h&gt; #include &lt;MPU.hpp&gt; #include &lt;I2Cbus.hpp&gt; #include &lt;mpu\/math.hpp&gt; static const char *TAG = &quot;MPU-driver-wrapper&quot;; extern &quot;C&quot; MPU_t *mpu_get_new_driver_object() { MPU_t *sensor = NULL; esp_err_t res = ESP_OK; i2c0.begin(GPIO_NUM_18, GPIO_NUM_21, 400000); sensor = new MPU_t(); sensor-&gt;setBus(i2c0); sensor-&gt;setAddr(mpud::MPU_I2CADDRESS_AD0_HIGH); if ((res = sensor-&gt;testConnection()) != ESP_OK) { ESP_LOGE(TAG, &quot;Failed to connect to the MPU, error=%#X (%s)&quot;, res, esp_err_to_name(res)); vTaskDelay(pdMS_TO_TICKS(100)); } ESP_ERROR_CHECK(sensor-&gt;initialize()); return sensor; } extern &quot;C&quot; esp_err_t mpu_accelerometer_read(MPU_t *MPU_driver, float *x, float *y, float *z) { mpud::raw_axes_t accelRaw; mpud::float_axes_t accelG; \/\/ Reading MPU_driver-&gt;acceleration(&amp;accelRaw); \/\/ Converting accelG = mpud::accelGravity(accelRaw, mpud::ACCEL_FS_4G); *x = accelG.x; *y = accelG.y; *z = accelG.z; return ESP_OK; } extern &quot;C&quot; esp_err_t mpu_gyroscope_read(MPU_t *MPU_driver, float *x, float *y, float *z) { mpud::raw_axes_t gyroRaw; mpud::float_axes_t gyroDPS; \/\/ Reading MPU_driver-&gt;rotation(&amp;gyroRaw); \/\/ Converting gyroDPS = mpud::gyroDegPerSec(gyroRaw, mpud::GYRO_FS_500DPS); *x = gyroDPS[0]; *y = gyroDPS[1]; *z = gyroDPS[2]; return ESP_OK; } Now that we have the MPU driver implementation, let's dive into the main component implementation! Main component implementation The main component is in charge of initializing the sensor and periodically print sensor values on the screen. The content of mpu65000-tester.c is: #include &lt;accelerometer-driver.h&gt; #include &lt;esp_log.h&gt; #include &lt;esp_err.h&gt; #include &lt;freertos\/FreeRTOS.h&gt; #include &lt;freertos\/task.h&gt; static const char* TAG = &quot;mpu6500-tester&quot;; void app_main() { mpu6500_sensor_t *sensor = NULL; ESP_ERROR_CHECK(mpu6500_sensor_init(&amp;sensor)); while (1) { float a_x, a_y, a_z, g_x, g_y, g_z; ESP_ERROR_CHECK(accelerometer_read(sensor, &amp;a_x, &amp;a_y, &amp;a_z)); ESP_LOGI(TAG, &quot;A (x, y, z) : (%+6.2f, %+6.2f, %+6.2f)&quot;, a_x, a_y, a_z); ESP_ERROR_CHECK(gyroscope_read(sensor, &amp;g_x, &amp;g_y, &amp;g_z)); ESP_LOGI(TAG, &quot;G (x, y, z) : (%+6.2f, %+6.2f, %+6.2f)&quot;, g_x, g_y, g_z); vTaskDelay(pdMS_TO_TICKS(4000)); } } Build and flash You have to select the correct MPU model before build and flash the project. To configure the project, open the menuconfig tool typing in the root folder project: idf.py menuconfig Go to Component config\/MPU driver\/MPU chip model and select the MPU6500 entry. Then close saving the changed configuration and compile the project with: idf.py build To flash and monitor the execution type on the terminal: idf.py -p &lt;serial_port&gt; flash monitor Replacing &lt;serial_port&gt; with the actual port (generally \/dev\/ttyUSB0 or similar on linux). When the flash operation finished, press the reset button. If everything went well, you will see on the terminal something like I (0) cpu_start: App cpu up. I (217) cpu_start: Pro cpu start user code I (217) cpu_start: cpu freq: 160000000 Hz I (217) cpu_start: Application information: I (222) cpu_start: Project name: mpu6500-tester I (227) cpu_start: App version: 1 I (232) cpu_start: Compile time: Oct 4 2023 09:15:44 I (238) cpu_start: ELF file SHA256: 291a143921ded781... I (244) cpu_start: ESP-IDF: v5.0.2 I (248) cpu_start: Min chip rev: v0.0 I (253) cpu_start: Max chip rev: v3.99 I (258) cpu_start: Chip rev: v3.0 I (263) heap_init: Initializing. RAM available for dynamic allocation: I (270) heap_init: At 3FFAE6E0 len 00001920 (6 KiB): DRAM I (276) heap_init: At 3FFB2848 len 0002D7B8 (181 KiB): DRAM I (282) heap_init: At 3FFE0440 len 00003AE0 (14 KiB): D\/IRAM I (289) heap_init: At 3FFE4350 len 0001BCB0 (111 KiB): D\/IRAM I (295) heap_init: At 4008D0F8 len 00012F08 (75 KiB): IRAM I (303) spi_flash: detected chip: generic I (306) spi_flash: flash io: dio I (311) cpu_start: Starting scheduler on PRO CPU. I (0) cpu_start: Starting scheduler on APP CPU. I (515) MPU6500: Reset! I (515) MPU6500: Sample rate set to 100 Hz I (515) MPU6500: Initialization complete I (515) mpu6500-tester: A (x, y, z) : ( -0.00, +0.03, +0.99) I (525) mpu6500-tester: G (x, y, z) : ( +0.20, -0.24, -0.21) I (4525) mpu6500-tester: A (x, y, z) : ( -0.01, +0.03, +0.99) I (4525) mpu6500-tester: G (x, y, z) : ( +0.56, -0.61, -0.40) I (8525) mpu6500-tester: A (x, y, z) : ( -0.01, +0.03, +0.99) I (8525) mpu6500-tester: G (x, y, z) : ( +0.52, -0.56, -0.46) I (12525) mpu6500-tester: A (x, y, z) : ( -0.01, +0.03, +0.99)","tags":"","url":"Advanced_Features\/Get_started_with_MPU6500.html"}]}